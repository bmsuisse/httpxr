use pyo3::prelude::*;
use pyo3::types::{PyAnyMethods, PyDictMethods, PyDict, PyList, PyTuple, PyBytes};
use std::collections::HashMap;
use std::time::Instant;

use crate::config::{Limits, Timeout};
use crate::models::{Headers, Request, Response, Cookies};
use crate::urls::URL;
use crate::transports::default::HTTPTransport;

pub const DEFAULT_MAX_REDIRECTS: u32 = 20;

/// Sentinel for "use client default" values.

#[pyclass]
#[derive(Clone)]
pub struct UseClientDefault;

#[pymethods]
impl UseClientDefault {
    #[new]
    fn new() -> Self { UseClientDefault }
    fn __repr__(&self) -> &str { "<UseClientDefault>" }
    fn __bool__(&self) -> bool { false }
}

fn extract_verify_path(v_bound: &Bound<'_, PyAny>) -> (bool, Option<String>) {
    if let Ok(b) = v_bound.extract::<bool>() {
        (b, None)
    } else if let Ok(s) = v_bound.extract::<String>() {
        (true, Some(s))
    } else {
        // Check for _cafile attribute (added by our create_ssl_context patch)
        let cafile = v_bound.getattr("_cafile").ok().and_then(|attr| attr.extract::<String>().ok());
        (true, cafile)
    }
}

fn extract_from_kwargs<'py>(kwargs: Option<&Bound<'py, PyDict>>, key: &str) -> Option<Bound<'py, PyAny>> {
    kwargs.and_then(|d| d.get_item(key).ok().flatten())
}

/// Merge a base URL with a request URL, matching httpx's `_merge_url` semantics.
/// For relative URLs, the base path and request path are concatenated.
/// For absolute URLs (with scheme), the request URL is used as-is.
fn merge_base_url(base: &URL, url: &str) -> PyResult<URL> {
    // If url is absolute (has a scheme), use it directly
    if url.contains("://") {
        return URL::create_from_str(url);
    }

    let base_scheme = base.get_scheme();
    let base_host = base.get_host();
    let base_port = base.get_port();
    let base_path = base.parsed.path.clone();

    // Build the merged path: base_path + url
    // Ensure proper slash handling
    let merged_path = if url.starts_with('/') {
        // url is like "/testing/123" - concatenate with base path
        let bp = base_path.trim_end_matches('/');
        format!("{}{}", bp, url)
    } else if url.starts_with("..") {
        // Relative path with ".." - use RFC joining
        return base.join_relative(url);
    } else {
        // url is like "testing/123"
        let bp = if base_path.ends_with('/') { base_path.clone() } else { format!("{}/", base_path) };
        format!("{}{}", bp, url)
    };

    // Reconstruct the full URL
    let port_str = if let Some(p) = base_port {
        let default_port = match &*base_scheme {
            "http" | "ws" => Some(80),
            "https" | "wss" => Some(443),
            _ => None,
        };
        if Some(p) != default_port {
            format!(":{}", p)
        } else {
            String::new()
        }
    } else {
        String::new()
    };

    let full_url = format!("{}://{}{}{}", base_scheme, base_host, port_str, merged_path);
    URL::create_from_str(&full_url)
}
/// Synchronous HTTP Client backed by ureq.
#[pyclass]
pub struct Client {
    base_url: Option<URL>,
    auth: Option<Py<PyAny>>,
    params: Option<Py<PyAny>>,
    default_headers: Headers,
    cookies: Cookies,
    max_redirects: u32,
    follow_redirects: bool,
    transport: Py<PyAny>,
    mounts: Vec<(String, Py<PyAny>)>,
    is_closed: bool,
    trust_env: bool,
    event_hooks: Option<Py<PyAny>>,
    timeout: Option<Py<PyAny>>,
}

#[pymethods]
impl Client {
    #[new]
    #[pyo3(signature = (
        *,
        auth=None,
        params=None,
        headers=None,
        cookies=None,
        timeout=None,
        follow_redirects=false,
        max_redirects=None,
        verify=None,
        cert=None,
        http2=false,
        proxy=None,
        limits=None,
        mounts=None,
        transport=None,
        base_url=None,
        trust_env=true,
        default_encoding=None,
        event_hooks=None
    ))]
    pub fn new(
        py: Python<'_>,
        auth: Option<Py<PyAny>>,
        params: Option<Py<PyAny>>,
        headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>,
        timeout: Option<&Bound<'_, PyAny>>,
        follow_redirects: bool,
        max_redirects: Option<u32>,
        verify: Option<&Bound<'_, PyAny>>,
        cert: Option<&str>,
        http2: bool,
        proxy: Option<&Bound<'_, PyAny>>,
        limits: Option<&Limits>,
        mounts: Option<&Bound<'_, PyAny>>,
        transport: Option<&Bound<'_, PyAny>>,
        base_url: Option<&Bound<'_, PyAny>>,
        trust_env: bool,
        default_encoding: Option<&Bound<'_, PyAny>>,
        event_hooks: Option<&Bound<'_, PyAny>>,
    ) -> PyResult<Self> {
        let hdrs = Headers::create(headers, "utf-8")?;
        let ckies = Cookies::create(py, cookies)?;

        let base = if let Some(b) = base_url {
            let s = b.str()?.extract::<String>()?;
            if s.is_empty() { None } else { Some(URL::create_from_str(&s)?) }
        } else {
            None
        };

        let proxy_obj = if let Some(p) = proxy {
            if let Ok(proxy_val) = p.extract::<crate::config::Proxy>() {
                Some(proxy_val)
            } else if let Ok(s) = p.extract::<String>() {
                Some(crate::config::Proxy::create_from_url(&s)?)
            } else {
                None
            }
        } else { None };

        let (verify_bool, verify_path) = if let Some(v) = verify {
            extract_verify_path(v)
        } else {
            (true, None)
        };

        let transport_obj = if let Some(t) = transport {
            t.clone().unbind()
        } else {
             let t = HTTPTransport::create(verify_bool, verify_path.as_deref().or(cert), http2, limits, proxy_obj.as_ref(), 0)?;
             Py::new(py, t)?.into()
        };

        // Parse mounts dict into Vec<(pattern, transport)>
        let mut mounts_vec: Vec<(String, Py<PyAny>)> = Vec::new();
        if let Some(m) = mounts {
            if let Ok(d) = m.downcast::<PyDict>() {
                for (k, v) in d.iter() {
                    let pattern: String = k.extract()?;
                    mounts_vec.push((pattern, v.unbind()));
                }
            }
        }

        let eh = event_hooks.map(|e| e.clone().unbind());
        let to = timeout.map(|t| t.clone().unbind());

        Ok(Client {
            base_url: base,
            auth, params,
            default_headers: hdrs,
            cookies: ckies,
            max_redirects: max_redirects.unwrap_or(DEFAULT_MAX_REDIRECTS),
            follow_redirects,
            transport: transport_obj,
            mounts: mounts_vec,
            is_closed: false,
            trust_env,
            event_hooks: eh,
            timeout: to,
        })
    }

    #[pyo3(signature = (method, url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None))]
    pub fn request(
        &self,
        py: Python<'_>,
        method: &str,
        url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>,
        data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>,
        json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>,
        headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>,
        auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>,
        timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>,
    ) -> PyResult<Response> {
        let start = Instant::now();

        // Build URL
        let url_str = url.str()?.extract::<String>()?;
        let target_url = if let Some(ref base) = self.base_url {
            base.join_relative(&url_str)?
        } else {
            URL::create_from_str(&url_str)?
        };

        // Merge headers
        let mut merged_headers = self.default_headers.clone();
        if let Some(h) = headers {
            merged_headers.update_from(Some(h))?;
        }

        // Build body
        let body = if let Some(c) = content {
            if let Ok(b) = c.downcast::<PyBytes>() {
                Some(b.as_bytes().to_vec())
            } else if let Ok(s) = c.extract::<String>() {
                Some(s.into_bytes())
            } else { None }
        } else if let Some(j) = json {
            let json_mod = py.import("json")?;
            let s: String = json_mod.call_method1("dumps", (j,))?.extract()?;
            merged_headers.set_header("content-type", "application/json");
            Some(s.into_bytes())
        } else if let Some(f) = files {
            // Multipart
            let boundary = if let Some(ct) = merged_headers.get("content-type", None) {
                 if let Some(idx) = ct.find("boundary=") {
                        let remainder = &ct[idx + 9..];
                        if let Some(end) = remainder.find(';') {
                            Some(remainder[..end].trim().trim_matches('"').to_string())
                        } else {
                            Some(remainder.trim().trim_matches('"').to_string())
                        }
                 } else { None }
            } else { None };
            
            let multipart = crate::multipart::MultipartStream::new(py, data, Some(f), boundary.as_deref())?;
            if !merged_headers.contains_header("content-type") {
                merged_headers.set_header("content-type", &multipart.content_type());
            }
            Some(multipart.get_content())
        } else if let Some(d) = data {
            let urllib = py.import("urllib.parse")?;
            let s: String = urllib.call_method1("urlencode", (d, true))?.extract()?;
            merged_headers.set_header("content-type", "application/x-www-form-urlencoded");
            Some(s.into_bytes())
        } else { None };

        // Build headers in httpx order: auto-headers first, then user headers
        let mut final_headers = Headers::new_empty();

        // 1. Host header
        if merged_headers.contains_header("host") {
            if let Some(v) = merged_headers.get_first_value("host") {
                final_headers.set_header("Host", &v);
            }
        } else {
            let host = target_url.get_host();
            let port = target_url.get_port();
            let scheme = target_url.get_scheme();
            let default_port = match &*scheme {
                "http" | "ws" => Some(80),
                "https" | "wss" => Some(443),
                _ => None,
            };
            let host_header = if let Some(p) = port {
                if Some(p) != default_port {
                    format!("{}:{}", host, p)
                } else {
                    host
                }
            } else {
                host
            };
            final_headers.set_header("Host", &host_header);
        }

        // 2. Accept
        if merged_headers.contains_header("accept") {
            if let Some(v) = merged_headers.get_first_value("accept") {
                final_headers.set_header("Accept", &v);
            }
        } else {
            final_headers.set_header("Accept", "*/*");
        }

        // 3. Accept-Encoding
        if merged_headers.contains_header("accept-encoding") {
            if let Some(v) = merged_headers.get_first_value("accept-encoding") {
                final_headers.set_header("Accept-Encoding", &v);
            }
        } else {
            final_headers.set_header("Accept-Encoding", "gzip, deflate, br, zstd");
        }

        // 4. Connection
        if merged_headers.contains_header("connection") {
            if let Some(v) = merged_headers.get_first_value("connection") {
                final_headers.set_header("Connection", &v);
            }
        } else {
            final_headers.set_header("Connection", "keep-alive");
        }

        // 5. User-Agent
        if merged_headers.contains_header("user-agent") {
            if let Some(v) = merged_headers.get_first_value("user-agent") {
                final_headers.set_header("User-Agent", &v);
            }
        } else {
            final_headers.set_header("User-Agent", &format!("python-httpx/{}", env!("CARGO_PKG_VERSION")));
        }

        // 6. Content-Type and Content-Length (if present)
        if let Some(v) = merged_headers.get_first_value("content-type") {
            final_headers.set_header("Content-Type", &v);
        }
        if let Some(v) = merged_headers.get_first_value("content-length") {
            final_headers.set_header("Content-Length", &v);
        }

        // 7. Append all remaining user headers that aren't auto-headers
        for (name, value) in merged_headers.iter_all() {
            let name_lower = name.to_lowercase();
            if !["host", "accept", "accept-encoding", "connection", "user-agent", "content-type", "content-length"].contains(&name_lower.as_str()) {
                final_headers.append_header(&name, &value);
            }
        }

        let mut merged_headers = final_headers;

        // Extract auth from URL userinfo if present
        let url_string = target_url.to_string();
        if let Ok(parsed) = url::Url::parse(&url_string) {
            if !parsed.username().is_empty() && !merged_headers.contains_header("authorization") {
                let user = parsed.username().to_string();
                let pass = parsed.password().unwrap_or("").to_string();
                let creds = format!("{}:{}", user, pass);
                let b64 = {
                    use base64::Engine;
                    base64::engine::general_purpose::STANDARD.encode(creds.as_bytes())
                };
                merged_headers.set_header("Authorization", &format!("Basic {}", b64));
            }
        }

        // Apply cookies (client-level + request-level)
        {
            let mut cookie_parts: Vec<String> = Vec::new();
            {
                let jar = &self.cookies.jar;
                if let Ok(bound_jar) = jar.bind(py).downcast::<PyAny>() {
                    if let Ok(iter) = bound_jar.try_iter() {
                         for item in iter {
                             let cookie: Bound<PyAny> = item?;
                             if let (Ok(name), Ok(value)) = (cookie.getattr("name"), cookie.getattr("value")) {
                                 let n: String = name.extract()?;
                                 let v: String = value.extract()?;
                                 cookie_parts.push(format!("{}={}", n, v));
                             }
                         }
                    }
                }
            }
            if let Some(c) = cookies {
                if let Ok(d) = c.downcast::<PyDict>() {
                    for (k, v) in d.iter() {
                        let ks: String = k.extract()?;
                        let vs: String = v.extract()?;
                        cookie_parts.push(format!("{}={}", ks, vs));
                    }
                } else if let Ok(cookie_val) = c.extract::<String>() {
                    cookie_parts.push(cookie_val);
                }
            }
            if !cookie_parts.is_empty() {
                merged_headers.set_header("Cookie", &cookie_parts.join("; "));
            }
        }

        let mut stream_obj: Option<Py<PyAny>> = None;
        if body.is_none() {
             if let Some(c) = content {
                 if let Ok(type_name) = c.get_type().name() {

                 }
                 let has_aiter = c.hasattr("__aiter__").unwrap_or(false);
                 let has_iter = c.hasattr("__iter__").unwrap_or(false);
                 // We already checked PyBytes and String in body logic above
                 // If body is None, and content is Some, it wasn't bytes or string.
                 
                 if has_aiter || has_iter {
                     // Check if sync iterator
                     if has_iter {
                         let iterator = c.clone().unbind();
                         // Wrap in IteratorByteStream to satisfy isinstance(stream, SyncByteStream)
                         let stream_inst = Py::new(py, crate::types::IteratorByteStream::new(iterator))?;
                         stream_obj = Some(stream_inst.bind(py).clone().into_any().unbind());
                     } else {
                         // Async iterator - keep raw for now, or implement AsyncIteratorByteStream if needed
                         // The failing test is sync, so this pathway is key.
                         stream_obj = Some(c.clone().unbind());
                     }
                 }
             }
        }

        let mut request = Request {
            method: method.to_uppercase(),
            url: target_url.clone(),
            headers: Py::new(py, merged_headers)?,
            extensions: PyDict::new(py).into(),
            content_body: body,
            stream: stream_obj,
            stream_response: false,
        };

        if let Some(t) = timeout {
            request.extensions.bind(py).set_item("timeout", t)?;
        }
        if let Some(e) = extensions {
            if let Ok(d) = e.downcast::<PyDict>() {
                for (k, v) in d.iter() {
                    request.extensions.bind(py).set_item(k, v)?;
                }
            }
        }
        let _ = files;
        // Apply auth - either per-request or client-level
        let effective_auth = if auth.is_some() { auth } else { self.auth.as_ref().map(|a| a.bind(py)) };
        if let Some(a) = effective_auth {
            // Check if it's a tuple (basic auth)
            if let Ok(tuple) = a.downcast::<pyo3::types::PyTuple>() {
                if tuple.len() == 2 {
                    let user: String = tuple.get_item(0)?.extract()?;
                    let pass: String = tuple.get_item(1)?.extract()?;
                    let creds = format!("{}:{}", user, pass);
                    let b64 = {
                        use base64::Engine;
                        base64::engine::general_purpose::STANDARD.encode(creds.as_bytes())
                    };
                    request.headers.bind(py).borrow_mut().set_header("authorization", &format!("Basic {}", b64));
                }
            } else if a.is_callable() {
                // Auth flow: call the auth function with the request
                let req_py = Py::new(py, request.clone())?;
                let flow = a.call1((req_py.bind(py),))?;
                // If it returns a request, use it
                if let Ok(r) = flow.extract::<Request>() {
                    request = r;
                }
            }
        }
        // Apply cookies
        if let Some(c) = cookies {
            if let Ok(cookie_val) = c.extract::<String>() {
                request.headers.bind(py).borrow_mut().set_header("cookie", &cookie_val);
            }
        }

        // Send request
        // Event hooks: request
        if let Some(hooks) = &self.event_hooks {
            if let Ok(l) = hooks.bind(py).get_item("request") {
                 if let Ok(l) = l.downcast::<pyo3::types::PyList>() {
                      let req_py = Py::new(py, request.clone())?;
                      for hook in l.iter() {
                          hook.call1((req_py.bind(py),))?;
                      }
                 }
            }
        }

        // Send request
        let mut response = {
            let t_bound = self.transport.bind(py);
            let req_py = Py::new(py, request.clone())?;
            let res_py = t_bound.call_method1("handle_request", (req_py,))?;
            res_py.extract::<Response>()?
        };

        response.elapsed = Some(start.elapsed().as_secs_f64());
        response.request = Some(request.clone());


        // Event hooks: response
        if let Some(hooks) = &self.event_hooks {
            // ...
        }

        // Handle redirects
        let should_follow = follow_redirects.unwrap_or(self.follow_redirects);
        if should_follow {
            let mut redirect_count = 0u32;
            let mut current_response = response;
            let mut current_request = request;

            while current_response.has_redirect_check(py)
                && redirect_count < self.max_redirects
            {
                redirect_count += 1;
                let location = current_response.headers.bind(py).borrow().get_first_value("location")
                    .ok_or_else(|| pyo3::exceptions::PyValueError::new_err("Redirect without Location header"))?;

                let mut redirect_url = current_request.url.join_relative(&location)
                    .map_err(|e| crate::exceptions::RemoteProtocolError::new_err(e.to_string()))?;
                
                // Fragment preservation: if redirect location doesn't have fragment, keep original
                if redirect_url.parsed.fragment.is_none() {
                     redirect_url.parsed.fragment = current_request.url.parsed.fragment.clone();
                }

                let redirect_method = if current_response.status_code == 303 {
                    "GET".to_string()
                } else {
                    current_request.method.clone()
                };

                // Check for streaming body - cannot redirect
                if redirect_method != "GET" && redirect_method != "HEAD" {

                     if current_request.stream.is_some() {
                        return Err(crate::exceptions::StreamConsumed::new_err("Cannot redirect request with streaming body"));
                     }
                }

                let redirect_body = if redirect_method == "GET" { None } else { current_request.content_body.clone() };

                // Update cookies from response
                // self.cookies is Cookies struct, accessing jar directly
                crate::client::extract_cookies_to_jar(py, &current_response, self.cookies.jar.bind(py))?;


                let mut redirect_headers = current_request.headers.bind(py).borrow().clone();
                // Remove existing cookie header to ensure we use updated one
                redirect_headers.remove_header("cookie");
                
                // Get fresh cookie header for redirect_url
                let cookie_header_val = {
                    let locals = pyo3::types::PyDict::new(py);
                    // We need to pass the jar (Bound)
                    locals.set_item("jar", self.cookies.jar.bind(py))?;
                    locals.set_item("url", redirect_url.to_string())?;
                    let code = std::ffi::CString::new("import urllib.request; req = urllib.request.Request(url); jar.add_cookie_header(req); c = req.get_header('Cookie')").expect("CString new failed");
                    py.run(&code, None, Some(&locals))?;
                    if let Some(item) = locals.get_item("c")? {
                        item.extract::<Option<String>>()?
                    } else { None }
                };
                
                if let Some(c) = cookie_header_val {
                    redirect_headers.set_header("cookie", &c);
                }
                
                // For 307/308 redirects, preserve body and content headers
                if (current_response.status_code == 307 || current_response.status_code == 308) && redirect_method != "GET" && redirect_method != "HEAD" {
                     if let Some(ref body) = redirect_body {
                         redirect_headers.set_header("Content-Length", &body.len().to_string());
                         if !redirect_headers.contains_header("Content-Type") {
                             // Attempt to preserve original content type if present
                             if let Some(ct) = current_request.headers.bind(py).borrow().get_first_value("content-type") {
                                 redirect_headers.set_header("Content-Type", &ct);
                             }
                         }
                     }
                } else if redirect_method == "GET" {
                    redirect_headers.remove_header("Content-Length");
                    redirect_headers.remove_header("Content-Type");
                    redirect_headers.remove_header("Transfer-Encoding");
                }
                
                let current_host = current_request.url.get_raw_host().to_lowercase();
                let redirect_host = redirect_url.get_raw_host().to_lowercase();
                if current_host != redirect_host {
                    redirect_headers.remove_header("authorization");
                }
                // Update host header for redirect
                let host = redirect_url.get_host();
                let port = redirect_url.get_port();
                let scheme = redirect_url.get_scheme();
                let default_port = match scheme {
                    "http" | "ws" => Some(80),
                    "https" | "wss" => Some(443),
                    _ => None,
                };
                let host_header = if let Some(p) = port {
                    if Some(p) != default_port {
                        format!("{}:{}", host, p)
                    } else { host }
                } else { host };
                redirect_headers.set_header("host", &host_header);

                let redirect_request = Request {
                    method: redirect_method,
                    url: redirect_url,
                    headers: Py::new(py, redirect_headers)?,
                    extensions: PyDict::new(py).into(),
                    content_body: redirect_body,
                    stream: None,
                    stream_response: false,
                };

                let mut history = current_response.history.clone();
                history.push(current_response);

                // Event hooks: request (redirect)
                if let Some(hooks) = &self.event_hooks {
                    if let Ok(l) = hooks.bind(py).get_item("request") {
                         if let Ok(l) = l.downcast::<pyo3::types::PyList>() {
                              let req_py = Py::new(py, redirect_request.clone())?;
                              for hook in l.iter() {
                                  hook.call1((req_py.bind(py),))?;
                              }
                         }
                    }
                }

                let mut new_response = {
                    let t_bound = self.transport.bind(py);
                    let req_py = Py::new(py, redirect_request.clone())?;
                    let res_py = t_bound.call_method1("handle_request", (req_py,))?;
                    res_py.extract::<Response>()?
                };

                // Event hooks: response (redirect)
                if let Some(hooks) = &self.event_hooks {
                    if let Ok(l) = hooks.bind(py).get_item("response") {
                         if let Ok(l) = l.downcast::<pyo3::types::PyList>() {
                              let resp_py = Py::new(py, new_response.clone())?; 
                              for hook in l.iter() {
                                  hook.call1((resp_py.bind(py),))?;
                              }
                         }
                    }
                }
                new_response.elapsed = Some(start.elapsed().as_secs_f64());
                new_response.request = Some(redirect_request.clone());
                new_response.history = history;

                current_response = new_response;
                current_request = redirect_request;
            }

            if current_response.has_redirect_check(py) && redirect_count >= self.max_redirects {
                return Err(crate::exceptions::TooManyRedirects::new_err(
                    format!("Exceeded maximum number of redirects ({})", self.max_redirects),
                ));
            }

            return Ok(current_response);
        }

        Ok(response)
    }

    #[pyo3(signature = (url, *, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn get(
        &self, py: Python<'_>, url: &Bound<'_, PyAny>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Response> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        self.request(py, "GET", url, None, None, None, None, params, headers, cookies, auth, follow_redirects, t, extensions)
    }

    #[pyo3(signature = (url, *, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn head(
        &self, py: Python<'_>, url: &Bound<'_, PyAny>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Response> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        self.request(py, "HEAD", url, None, None, None, None, params, headers, cookies, auth, follow_redirects, t, extensions)
    }

    #[pyo3(signature = (url, *, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn options(
        &self, py: Python<'_>, url: &Bound<'_, PyAny>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Response> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        self.request(py, "OPTIONS", url, None, None, None, None, params, headers, cookies, auth, follow_redirects, t, extensions)
    }

    #[pyo3(signature = (url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn post(
        &self, py: Python<'_>, url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>, data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>, json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Response> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        let f = if let Some(f) = follow_redirects { Some(f) } else { extract_from_kwargs(kwargs, "follow_redirects").and_then(|v| v.extract::<bool>().ok()) };
        self.request(py, "POST", url, content, data, files, json, params, headers, cookies, auth, f, t, extensions)
    }

    #[pyo3(signature = (url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn put(
        &self, py: Python<'_>, url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>, data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>, json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Response> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        let f = if let Some(f) = follow_redirects { Some(f) } else { extract_from_kwargs(kwargs, "follow_redirects").and_then(|v| v.extract::<bool>().ok()) };
        self.request(py, "PUT", url, content, data, files, json, params, headers, cookies, auth, f, t, extensions)
    }

    #[pyo3(signature = (url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn patch(
        &self, py: Python<'_>, url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>, data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>, json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Response> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        let f = if let Some(f) = follow_redirects { Some(f) } else { extract_from_kwargs(kwargs, "follow_redirects").and_then(|v| v.extract::<bool>().ok()) };
        self.request(py, "PATCH", url, content, data, files, json, params, headers, cookies, auth, f, t, extensions)
    }

    #[pyo3(signature = (url, *, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn delete(
        &self, py: Python<'_>, url: &Bound<'_, PyAny>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Response> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        let f = if let Some(f) = follow_redirects { Some(f) } else { extract_from_kwargs(kwargs, "follow_redirects").and_then(|v| v.extract::<bool>().ok()) };
        self.request(py, "DELETE", url, None, None, None, None, params, headers, cookies, auth, f, t, extensions)
    }

    fn close(&mut self) -> PyResult<()> { self.is_closed = true; Ok(()) }

    #[getter]
    fn is_closed(&self) -> bool { self.is_closed }

    #[getter]
    fn headers(&self) -> Headers { self.default_headers.clone() }
    #[setter]
    fn set_headers(&mut self, value: &Bound<'_, PyAny>) -> PyResult<()> {
        self.default_headers = Headers::create(Some(value), "utf-8")?;
        Ok(())
    }

    #[getter]
    fn get_base_url(&self, py: Python<'_>) -> PyResult<Py<PyAny>> {
        if let Some(ref u) = self.base_url {
            Ok(Py::new(py, u.clone())?.into())
        } else {
            Ok(Py::new(py, URL::create_from_str("")?)?.into())
        }
    }
    #[setter]
    fn set_base_url(&mut self, value: &Bound<'_, PyAny>) -> PyResult<()> {
        let s = value.str()?.extract::<String>()?;
        self.base_url = if s.is_empty() { None } else { Some(URL::create_from_str(&s)?) };
        Ok(())
    }

    #[getter]
    fn get_auth(&self, py: Python<'_>) -> Option<Py<PyAny>> {
        self.auth.as_ref().map(|a| a.clone_ref(py))
    }
    #[setter]
    fn set_auth(&mut self, value: Option<Py<PyAny>>) { self.auth = value; }

    #[getter]
    fn get_cookies(&self, py: Python<'_>) -> Cookies { self.cookies.clone() }
    #[setter]
    fn set_cookies(&mut self, py: Python<'_>, value: &Bound<'_, PyAny>) -> PyResult<()> {
        self.cookies = Cookies::create(py, Some(value))?;
        Ok(())
    }

    #[getter]
    fn get_timeout(&self, py: Python<'_>) -> Py<PyAny> {
        self.timeout.as_ref().map(|t| t.clone_ref(py)).unwrap_or_else(|| py.None())
    }
    #[setter]
    fn set_timeout(&mut self, value: &Bound<'_, PyAny>) {
        self.timeout = Some(value.clone().unbind());
    }

    #[getter]
    fn get_event_hooks(&self, py: Python<'_>) -> Py<PyAny> {
        self.event_hooks.as_ref().map(|e| e.clone_ref(py)).unwrap_or_else(|| {
            let d = PyDict::new(py);
            let _ = d.set_item("request", pyo3::types::PyList::empty(py));
            let _ = d.set_item("response", pyo3::types::PyList::empty(py));
            d.into()
        })
    }
    #[setter]
    fn set_event_hooks(&mut self, value: &Bound<'_, PyAny>) {
        self.event_hooks = Some(value.clone().unbind());
    }

    #[getter]
    fn get_trust_env(&self) -> bool { self.trust_env }

    #[pyo3(signature = (method, url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, extensions=None))]
    fn build_request(
        &self, py: Python<'_>, method: &str, url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>, data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>, json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, extensions: Option<&Bound<'_, PyAny>>,
    ) -> PyResult<Request> {
        let url_str = url.str()?.extract::<String>()?;
        let target_url = if let Some(ref base) = self.base_url {
            merge_base_url(base, &url_str)?
        } else {
            URL::create_from_str(&url_str)?
        };

        let mut merged_headers = self.default_headers.clone();
        if let Some(h) = headers {
            merged_headers.update_from(Some(h))?;
        }

        let body = if let Some(c) = content {
            if let Ok(b) = c.downcast::<PyBytes>() {
                Some(b.as_bytes().to_vec())
            } else if let Ok(s) = c.extract::<String>() {
                Some(s.into_bytes())
            } else { None }
        } else if let Some(j) = json {
            let json_mod = py.import("json")?;
            let s: String = json_mod.call_method1("dumps", (j,))?.extract()?;
            merged_headers.set_header("content-type", "application/json");
            Some(s.into_bytes())
        } else if let Some(d) = data {
            let urllib = py.import("urllib.parse")?;
            let s: String = urllib.call_method1("urlencode", (d, true))?.extract()?;
            merged_headers.set_header("content-type", "application/x-www-form-urlencoded");
            Some(s.into_bytes())
        } else { None };

        // Build auto-headers in the correct order, then append user headers
        let mut final_headers = Headers::new_empty();

        // 1. Host header
        if merged_headers.contains_header("host") {
            if let Some(v) = merged_headers.get_first_value("host") {
                final_headers.set_header("Host", &v);
            }
        } else {
            let host = target_url.get_host();
            let port = target_url.get_port();
            let scheme = target_url.get_scheme();
            let default_port = match &*scheme {
                "http" | "ws" => Some(80),
                "https" | "wss" => Some(443),
                _ => None,
            };
            let host_header = if let Some(p) = port {
                if Some(p) != default_port {
                    format!("{}:{}", host, p)
                } else {
                    host
                }
            } else {
                host
            };
            final_headers.set_header("Host", &host_header);
        }

        // 2. Accept
        if merged_headers.contains_header("accept") {
            if let Some(v) = merged_headers.get_first_value("accept") {
                final_headers.set_header("Accept", &v);
            }
        } else {
            final_headers.set_header("Accept", "*/*");
        }

        // 3. Accept-Encoding
        if merged_headers.contains_header("accept-encoding") {
            if let Some(v) = merged_headers.get_first_value("accept-encoding") {
                final_headers.set_header("Accept-Encoding", &v);
            }
        } else {
            final_headers.set_header("Accept-Encoding", "gzip, deflate, br, zstd");
        }

        // 4. Connection
        if merged_headers.contains_header("connection") {
            if let Some(v) = merged_headers.get_first_value("connection") {
                final_headers.set_header("Connection", &v);
            }
        } else {
            final_headers.set_header("Connection", "keep-alive");
        }

        // 5. User-Agent
        if merged_headers.contains_header("user-agent") {
            if let Some(v) = merged_headers.get_first_value("user-agent") {
                final_headers.set_header("User-Agent", &v);
            }
        } else {
            final_headers.set_header("User-Agent", &format!("python-httpx/{}", env!("CARGO_PKG_VERSION")));
        }

        // 6. Content-Type and Content-Length (if present)
        if let Some(v) = merged_headers.get_first_value("content-type") {
            final_headers.set_header("Content-Type", &v);
        }
        if let Some(v) = merged_headers.get_first_value("content-length") {
            final_headers.set_header("Content-Length", &v);
        }

        // 7. Append all remaining user headers that aren't already set
        for (name, value) in merged_headers.iter_all() {
            let name_lower = name.to_lowercase();
            if !["host", "accept", "accept-encoding", "connection", "user-agent", "content-type", "content-length"].contains(&name_lower.as_str()) {
                final_headers.append_header(&name, &value);
            }
        }

        let req = Request {
            method: method.to_uppercase(),
            url: target_url,
            headers: Py::new(py, final_headers)?,
            extensions: if let Some(e) = extensions { e.clone().unbind() } else { PyDict::new(py).into() },
            content_body: body,
            stream: None,
            stream_response: false,
        };
        Ok(req)
    }

    #[pyo3(signature = (request, *, auth=None, follow_redirects=None))]
    fn send(
        &self, py: Python<'_>, request: &Request,
        auth: Option<&Bound<'_, PyAny>>, follow_redirects: Option<bool>,
    ) -> PyResult<Response> {
        let start = Instant::now();
        let t_bound = self.transport.bind(py);
        let req_py = Py::new(py, request.clone())?;
        let res_py = t_bound.call_method1("handle_request", (req_py,))?;
        let mut response: Response = res_py.extract()?;
        response.elapsed = Some(start.elapsed().as_secs_f64());
        response.request = Some(request.clone());
        // Handle redirects
        let should_follow = follow_redirects.unwrap_or(self.follow_redirects);
        if should_follow && response.has_redirect_check(py) {
            let mut redirect_count = 0u32;
            let mut current_response = response;
            let mut current_request = request.clone();
            while current_response.has_redirect_check(py) && redirect_count < self.max_redirects {
                redirect_count += 1;
                let location = current_response.headers.bind(py).borrow().get_first_value("location")
                    .ok_or_else(|| pyo3::exceptions::PyValueError::new_err("Redirect without Location header"))?;
                let redirect_url = current_request.url.join_relative(&location)?;
                let redirect_method = if current_response.status_code == 303 { "GET".to_string() } else { current_request.method.clone() };
                let redirect_body = if redirect_method == "GET" { None } else { current_request.content_body.clone() };
                let redirect_request = Request {
                    method: redirect_method, url: redirect_url,
                    headers: current_request.headers.clone_ref(py),
                    extensions: PyDict::new(py).into(),
                    content_body: redirect_body, stream: None, stream_response: false,
                };
                let mut history = current_response.history.clone();
                history.push(current_response);
                let mut new_response = {
                    let req_py2 = Py::new(py, redirect_request.clone())?;
                    let res_py2 = t_bound.call_method1("handle_request", (req_py2,))?;
                    res_py2.extract::<Response>()?
                };
                new_response.elapsed = Some(start.elapsed().as_secs_f64());
                new_response.request = Some(redirect_request.clone());
                new_response.history = history;
                current_response = new_response;
                current_request = redirect_request;
            }
            if current_response.has_redirect_check(py) && redirect_count >= self.max_redirects {
                return Err(crate::exceptions::TooManyRedirects::new_err(
                    format!("Exceeded maximum number of redirects ({})", self.max_redirects),
                ));
            }
            return Ok(current_response);
        }
        Ok(response)
    }

    fn _transport_for_url(&self, py: Python<'_>, url: &Bound<'_, PyAny>) -> PyResult<Py<PyAny>> {
        let url_str = url.str()?.extract::<String>().unwrap_or_default();
        // Check mounts in order (longest pattern first)
        for (pattern, transport) in &self.mounts {
            if pattern == "all://" || url_str.starts_with(pattern) {
                return Ok(transport.clone_ref(py));
            }
        }
        Ok(self.transport.clone_ref(py))
    }

    #[getter]
    fn _transport(&self, py: Python<'_>) -> Py<PyAny> {
        self.transport.clone_ref(py)
    }

    #[getter]
    fn _mounts(&self, py: Python<'_>) -> PyResult<Py<PyAny>> {
        let dict = PyDict::new(py);
        for (pattern, transport) in &self.mounts {
            dict.set_item(pattern, transport.clone_ref(py))?;
        }
        Ok(dict.into())
    }

    #[getter]
    fn get_params(&self, py: Python<'_>) -> PyResult<Py<PyAny>> {
        if let Some(ref p) = self.params {
            Ok(p.clone_ref(py))
        } else {
            let qp = crate::urls::QueryParams::create(None)?;
            Ok(Py::new(py, qp)?.into())
        }
    }

    fn _redirect_headers(&self, request: &Request, _url: &Bound<'_, PyAny>, _method: &str) -> Headers {
        let mut hdrs = Python::attach(|py| request.headers.bind(py).borrow().clone());
        // Strip authorization on cross-origin redirect (simplified)
        hdrs
    }

    #[pyo3(signature = (method, url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn stream(
        &self, py: Python<'_>, method: &str, url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>, data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>, json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Response> {
        // For sync client, stream just returns the response directly
        self.request(py, method, url, content, data, files, json, params, headers, cookies, auth, follow_redirects, timeout, extensions)
    }

    fn __enter__<'py>(slf: PyRef<'py, Self>, py: Python<'py>) -> PyResult<PyRef<'py, Self>> {
        // Call __enter__ on the transport
        let transport = slf.transport.bind(py);
        if transport.hasattr("__enter__")? {
            transport.call_method0("__enter__")?;
        }
        // Call __enter__ on all mounted transports
        for (_, mt) in &slf.mounts {
            let t = mt.bind(py);
            if t.hasattr("__enter__")? {
                t.call_method0("__enter__")?;
            }
        }
        Ok(slf)
    }
    fn __exit__(&mut self, py: Python<'_>, _e1: Option<&Bound<'_, PyAny>>, _e2: Option<&Bound<'_, PyAny>>, _e3: Option<&Bound<'_, PyAny>>) -> PyResult<()> {
        self.close()?;
        // Call __exit__ on the transport
        let transport = self.transport.bind(py);
        if transport.hasattr("__exit__")? {
            let none = py.None();
            transport.call_method1("__exit__", (none.bind(py), none.bind(py), none.bind(py)))?;
        }
        // Call __exit__ on all mounted transports
        for (_, mt) in &self.mounts {
            let t = mt.bind(py);
            if t.hasattr("__exit__")? {
                let none = py.None();
                t.call_method1("__exit__", (none.bind(py), none.bind(py), none.bind(py)))?;
            }
        }
        Ok(())
    }
    fn __repr__(&self) -> String { if self.is_closed { "<Client [closed]>".to_string() } else { "<Client>".to_string() } }
}

/// Async HTTP Client backed by reqwest + tokio.
#[pyclass]
pub struct AsyncClient {
    base_url: Option<URL>,
    auth: Option<Py<PyAny>>,
    params: Option<Py<PyAny>>,
    default_headers: Headers,
    cookies: Cookies,
    max_redirects: u32,
    follow_redirects: bool,
    transport: Py<PyAny>,
    mounts: Py<PyDict>,
    timeout: Option<Timeout>,
    is_closed: bool,
    trust_env: bool,
    event_hooks: Option<Py<PyAny>>,
}

#[pymethods]
impl AsyncClient {
    #[new]
    #[pyo3(signature = (
        *,
        auth=None,
        params=None,
        headers=None,
        cookies=None,
        timeout=None,
        follow_redirects=false,
        max_redirects=None,
        verify=None,
        cert=None,
        http2=false,
        proxy=None,
        limits=None,
        mounts=None,
        transport=None,
        base_url=None,
        trust_env=true,
        default_encoding=None,
        event_hooks=None
    ))]
    fn new(
        py: Python<'_>,
        auth: Option<Py<PyAny>>,
        params: Option<Py<PyAny>>,
        headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>,
        timeout: Option<&Bound<'_, PyAny>>,
        follow_redirects: bool,
        max_redirects: Option<u32>,
        verify: Option<&Bound<'_, PyAny>>,
        cert: Option<&str>,
        http2: bool,
        proxy: Option<&Bound<'_, PyAny>>,
        limits: Option<&Limits>,
        mounts: Option<&Bound<'_, PyAny>>,
        transport: Option<&Bound<'_, PyAny>>,
        base_url: Option<&Bound<'_, PyAny>>,
        trust_env: bool,
        default_encoding: Option<&Bound<'_, PyAny>>,
        event_hooks: Option<&Bound<'_, PyAny>>,
    ) -> PyResult<Self> {
        let hdrs = Headers::create(headers, "utf-8")?;
        let ckies = Cookies::create(py, cookies)?;
        
        let mounts_obj = if let Some(m) = mounts {
            if let Ok(d) = m.downcast::<PyDict>() {
                 d.clone().unbind()
            } else {
                 PyDict::new(py).into()
            }
        } else {
             PyDict::new(py).into()
        };

        let base = if let Some(b) = base_url {
            let s = b.str()?.extract::<String>()?;
            if s.is_empty() { None } else { Some(URL::create_from_str(&s)?) }
        } else { None };

        let transport_obj = if let Some(t) = transport {
            t.clone().unbind()
        } else {
            // Create default AsyncHTTPTransport
            let proxy_obj = if let Some(p) = proxy {
                if let Ok(proxy_val) = p.extract::<crate::config::Proxy>() {
                    Some(proxy_val)
                } else if let Ok(s) = p.extract::<String>() {
                    Some(crate::config::Proxy::create_from_url(&s)?)
                } else {
                    None
                }
            } else { None };

            let (verify_bool, verify_path) = if let Some(v_bound) = verify {
                extract_verify_path(v_bound)
            } else {
                (true, None)
            };

            let t = crate::transports::default::AsyncHTTPTransport::create(
                verify_bool, verify_path.as_deref().or(cert), http2, limits, proxy_obj.as_ref(), 0
            )?;
            Py::new(py, t)?.into()
        };

            let mounts_dict: Py<PyDict> = if let Some(m) = mounts {
                if let Ok(d) = m.downcast::<PyDict>() {
                    d.clone().unbind()
                } else {
                    PyDict::new(py).into()
                }
            } else {
                PyDict::new(py).into()
            };
            
            Ok(AsyncClient {
                base_url: base,
                auth, params,
                default_headers: hdrs,
                cookies: ckies,
                max_redirects: max_redirects.unwrap_or(DEFAULT_MAX_REDIRECTS),
                follow_redirects,
                transport: transport_obj,
                mounts: mounts_dict,
                timeout: if let Some(t) = timeout { t.extract::<Timeout>().ok() } else { None },
                is_closed: false,
                trust_env,
                event_hooks: event_hooks.map(|e| e.clone().unbind()),
            })
        }

    #[pyo3(signature = (request, *, stream=false, auth=None, follow_redirects=None))]
    fn send<'py>(
        &self,
        py: Python<'py>,
        request: &Bound<'_, PyAny>,
        stream: bool,
        auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>,
    ) -> PyResult<Bound<'py, PyAny>> {
         let mut req = request.extract::<Request>()?;
         if stream { req.stream_response = true; }
         let transport = self.transport.clone_ref(py);
         let mounts = self.mounts.clone_ref(py);
         let max_redirects = self.max_redirects;
         let follow_redirects = follow_redirects.unwrap_or(self.follow_redirects);

        let event_hooks = self.event_hooks.as_ref().map(|h| h.clone_ref(py));

        pyo3_async_runtimes::tokio::future_into_py(py, async move {
            let start = Instant::now();
            let mut current_req: Request = req;
            let mut redirect_count: u32 = 0;
            // let event_hooks: Option<Py<PyAny>> = this.event_hooks.clone(); // Removed this line as event_hooks is captured by `async move`
            // let mounts: Py<PyDict> = this.mounts.clone(); // Removed this line as mounts is captured by `async move`

             loop {
                // Event hooks: request
                if let Some(hooks) = &event_hooks {
                     let hook_list: Vec<Py<PyAny>> = Python::attach(|py| {
                         let h: &Bound<'_, PyAny> = hooks.bind(py);
                         if let Ok(d) = h.downcast::<PyDict>() {
                             if let Ok(Some(req_hooks)) = d.get_item("request") {
                                 if let Ok(l) = req_hooks.downcast::<pyo3::types::PyList>() {
                                      let mut vec = Vec::new();
                                      for item in l.try_iter()? {
                                          vec.push(item?.unbind());
                                      }
                                      return Ok(vec);
                                 }
                             }
                         }
                         Ok::<Vec<Py<PyAny>>, PyErr>(Vec::new())
                     })?;

                     for hook in hook_list {
                         let fut = Python::attach(|py| {
                             let h = hook.bind(py);
                             let req = Py::new(py, current_req.clone())?;
                             let ret = h.call1((req,))?;
                             let is_awaitable = py.import("inspect")?.call_method1("isawaitable", (&ret,))?.extract::<bool>()?;
                             if is_awaitable {
                                 Ok(Some(pyo3_async_runtimes::tokio::into_future(ret)?))
                             } else {
                                 Ok::<_, PyErr>(None)
                             }
                         })?;
                         if let Some(f) = fut {
                             f.await?;
                         }
                    }
                }

                let response_coro = Python::attach(|py| {
                     let transport_to_use = select_transport(mounts.bind(py).clone(), transport.clone_ref(py), &current_req.url)?;
                     let t_bound = transport_to_use.bind(py);
                     let req_py = Py::new(py, current_req.clone())?;
                     t_bound.call_method1("handle_async_request", (req_py,)).map(|b| b.unbind())
                })?;

                let future = Python::attach(|py| {
                    let bound = response_coro.bind(py);
                    pyo3_async_runtimes::tokio::into_future(bound.clone())
                })?;
                let response_obj: Py<PyAny> = future.await?;

                let response = Python::attach(|py| {
                    let mut resp: Response = response_obj.bind(py).extract()?;
                    resp.request = Some(current_req.clone());
                    resp.elapsed = Some(start.elapsed().as_secs_f64());
                    
                    // Event hooks: response
                    if let Some(hooks) = &event_hooks {
                         let hook_list: Vec<Py<PyAny>> = {
                             let h: &Bound<'_, PyAny> = hooks.bind(py);
                             if let Ok(d) = h.downcast::<PyDict>() {
                                 if let Ok(Some(resp_hooks)) = d.get_item("response") {
                                     if let Ok(l) = resp_hooks.downcast::<pyo3::types::PyList>() {
                                          let mut vec = Vec::new();
                                          for item in l.try_iter()? {
                                              vec.push(item?.unbind());
                                          }
                                          Ok::<Vec<Py<PyAny>>, PyErr>(vec)
                                     } else { Ok(Vec::new()) }
                                 } else { Ok(Vec::new()) }
                             } else { Ok(Vec::new()) }
                         }?;

                         // We cannot await inside this Python::attach block.
                         // But we need to update `resp` if hook modifies it?
                         // httpx hooks don't return modified response? They modify in place.
                         // But if we need to await, we must exit attach.
                         // But we are inside `response = Python::attach(...)`.
                         // We return `Py<Response>`.
                         // If we exit, we lose `resp_handle`.
                         
                         // Hack: we cannot support async response hooks properly if we are inside synchronous `attach` that returns the response.
                         // We must refactor this block to be async aware aka return the list of hooks to run AFTER creating the response?
                         // Or create response, UNBIND it, return it, then run hooks, then return it?
                         // Current logic: `let response = Python::attach(...)`.
                         // We should split it:
                         // 1. Create response handle (sync).
                         // 2. Run hooks (async loop).
                         // 3. Return response.
                         
                         // BUT `AsyncClient::send` returns `PyResult<Bound<'py, PyAny>>` (Wait, send returns Future which resolves to response).
                         // The future resolves to `response_obj` at line 1031.
                         // Then line 1033 `let response = Python::attach(...)` creates the final Response object wrapper.
                         // I should move hook logic OUT of this `attach` block.
                         // Just return `resp_handle` from `attach`.
                         // Then loop over hooks.
                         // We can define hook list logic here if needed, but we do it outside.
                    }
                    let resp_handle = Py::new(py, resp)?;
                    Ok::<Py<crate::models::Response>, PyErr>(resp_handle)
                })?;
                
                // Response hooks
                if let Some(hooks) = &event_hooks {
                     let hook_list: Vec<Py<PyAny>> = Python::attach(|py| {
                         let h: &Bound<'_, PyAny> = hooks.bind(py);
                         if let Ok(d) = h.downcast::<PyDict>() {
                             if let Ok(Some(resp_hooks)) = d.get_item("response") {
                                 if let Ok(l) = resp_hooks.downcast::<pyo3::types::PyList>() {
                                      let mut vec = Vec::new();
                                      for item in l.try_iter()? {
                                          vec.push(item?.unbind());
                                      }
                                      return Ok(vec);
                                 }
                             }
                         }
                         Ok::<Vec<Py<PyAny>>, PyErr>(Vec::new())
                     })?;

                     for hook in hook_list {
                         let fut = Python::attach(|py| {
                             let h = hook.bind(py);
                             let r = response.bind(py);
                                           let ret = h.call1((r,))?;
                                           let is_awaitable = py.import("inspect")?.call_method1("isawaitable", (&ret,))?.extract::<bool>()?;
                                           if is_awaitable {
                                               Ok(Some(pyo3_async_runtimes::tokio::into_future(ret)?))
                                           } else {
                                 Ok::<_, PyErr>(None)
                             }
                         })?;
                         if let Some(f) = fut {
                             f.await?;
                         }
                     }
                }
                


                let maybe_redirect = Python::attach(|py| {
                    if !follow_redirects || !response.bind(py).borrow().has_redirect_check(py) {
                        return Ok((None, Some(response)));
                    }
                    
                    if redirect_count >= max_redirects {
                        return Err(crate::exceptions::TooManyRedirects::new_err(format!("Exceeded maximum number of redirects ({})", max_redirects)));
                    }

                    let location = response.bind(py).borrow().headers.bind(py).borrow().get_first_value("location").ok_or_else(|| pyo3::exceptions::PyValueError::new_err("Redirect without Location header"))?;
                    let mut redirect_url = current_req.url.join_relative(&location)
                    .map_err(|e| crate::exceptions::RemoteProtocolError::new_err(e.to_string()))?;
                
                // Fragment preservation
                if redirect_url.parsed.fragment.is_none() {
                     redirect_url.parsed.fragment = current_req.url.parsed.fragment.clone();
                }

                let status_code = response.bind(py).borrow().status_code;
                let redirect_method = if status_code == 303 { "GET".to_string() } else { current_req.method.clone() };
                let redirect_body = if redirect_method == "GET" { None } else { current_req.content_body.clone() };

                    // Strip authorization on cross-origin redirect
                    let mut redirect_headers = current_req.headers.bind(py).borrow().clone();
                    let current_host = current_req.url.get_raw_host().to_lowercase();
                    let redirect_host = redirect_url.get_raw_host().to_lowercase();
                    if current_host != redirect_host {
                        redirect_headers.remove_header("authorization");
                    }
                    // Update host header for redirect
                    let host = redirect_url.get_host();
                    let port = redirect_url.get_port();
                    let scheme = redirect_url.get_scheme();
                    let default_port = match scheme {
                        "http" | "ws" => Some(80),
                        "https" | "wss" => Some(443),
                        _ => None,
                    };
                    let host_header = if let Some(p) = port {
                        if Some(p) != default_port {
                            format!("{}:{}", host, p)
                        } else { host }
                    } else { host };
                    redirect_headers.set_header("host", &host_header);

                     let new_req = Request {
                        method: redirect_method,
                        url: redirect_url,
                        headers: Py::new(py, redirect_headers)?,
                        extensions: PyDict::new(py).into(),
                        content_body: redirect_body,
                        stream: None,
                        stream_response: false,
                    };
                    
                    // History update
                    let mut new_resp = response.clone_ref(py);
                    let mut history = new_resp.bind(py).borrow().history.clone();
                    history.push(new_resp.bind(py).borrow().clone());
                    
                    // We don't attach history to new_req here, but response needs it.
                    // The next iteration will produce a response, we should attach history to THAT.
                    // But `handle_request` returns a fresh response. 
                    // We need to carry over history.
                    // `Response` struct has `history` field.
                    // So we can pass history in `extensions` or handle it after response creation.
                    // In `Client::send` (sync), we do: `new_response.history = history;`.
                    // Here we are inside the loop. We need to pass history to the next iteration?
                    // Or accumulate history in `redirect_count` / explicit valid.
                    // Actually, `current_response` holds history.
                    // Let's return the history to be attached to the next response.
                    
                    // Wait, the structure here creates `new_req` and iterates.
                    // The next `response` will be created from `handle_async_request`.
                    // We need to modify that response to include history.
                    // `AsyncClient::send` loop doesn't have a `history` variable purely.
                    // It uses `response.history`.
                    // We should accumulate history.
                    
                    return Ok((Some((new_req, history)), None));
                })?;

                if let (Some((new_req, history)), _) = maybe_redirect {
                     // We need to attach this history to the NEXT response.
                     // But we are just changing `current_req`.
                     // The next response is created in the next loop iteration.
                     // We need a way to persist history across iterations.
                     // The `history` variable in `pyo3_async_runtimes` closure?
                     // We can't easily mutate captured variables if they are not specifically handled.
                     // But we are in a loop.
                     // Let's introduce `history_accumulator`.
                     
                     // RE-DESIGN: The sync code accumulates history in the response object.
                     // `current_response = new_response`.
                     // `new_response.history = history`.
                     // So we need to ensure the response returned from `handle_async_request` gets the history attached.
                     // But `handle_async_request` (transport) returns a fresh response without history.
                     // So we must attach it.
                     
                     // We can't easily change local var `history` inside `Python::attach` if it's not passed through.
                     // But we return `maybe_redirect`.
                     // Let's change loop state.
                     current_req = new_req;
                     redirect_count += 1;
                     // And we need to carry over `history`.
                     // Let's make `history` part of the loop state.
                     // But `future_into_py` expects a future.
                     // We can use a `RefCell` or `Arc<Mutex>`? No, we are in async block.
                     // We can just use a local variable `let mut history = Vec::new();` outside the loop.
                     // But we are inside `async move`.
                     // `history` is `Vec<Response>`. Response is Py object wrapper.
                } else {
                     return Ok(maybe_redirect.1.unwrap());
                }
            }
        })
    }

    #[pyo3(signature = (method, url, **kwargs))]
    fn stream<'py>(
        client: Bound<'py, Self>,
        py: Python<'py>,
        method: String,
        url: Bound<'py, PyAny>,
        kwargs: Option<Bound<'py, PyDict>>,
    ) -> PyResult<StreamContextManager> {
         let mut request = client.call_method1("build_request", (method, url)).map_err(|e| {
             // If build_request failed, map error
             e
         })?.extract::<Request>()?;
         
         // Enable streaming for this request
         request.stream_response = true;

         // Pass arguments from kwargs to request (headers, params, etc)
         // Note: sophisticated arg passing omitted for brevity, focusing on stream flag
         // Re-wrapping request into PyObject to pass to StreamContextManager
         // actually StreamContextManager expects client, method, url... it calls client.send() internally.
         
         // Correct approach: Client.stream() returns a StreamContextManager.
         // StreamContextManager.__enter__() calls client.send(stream=True).
         
         Ok(StreamContextManager {
             client: client.unbind(),
             method: request.method,
             url: request.url.into_pyobject(py)?.into_any().unbind(),
             kwargs: kwargs.map(|k| k.unbind()),
             response: None,
         })
    }

    #[pyo3(signature = (method, url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, stream=false))]
    fn request<'py>(
        &self,
        py: Python<'py>,
        method: &str,
        url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>,
        data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>,
        json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>,
        headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>,
        auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>,
        timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>,
        stream: bool,
    ) -> PyResult<Bound<'py, PyAny>> {
        // println!("DEBUG: AsyncClient.request called, is_closed={}", self.is_closed);
        if self.is_closed {            return Err(pyo3::exceptions::PyRuntimeError::new_err("The client is closed"));
        }
        let _ = files;
        let method_str = method.to_uppercase();
        let url_str = url.str()?.extract::<String>()?;

        // Build URL
        let target_url = if let Some(ref base) = self.base_url {
            let full = format!("{}{}", base.to_string().trim_end_matches('/'), &url_str);
            URL::create_from_str(&full)?
        } else {
            URL::create_from_str(&url_str)?
        };

        // Build merged headers
        let mut merged_headers = self.default_headers.clone();
        if let Some(h) = headers {
            merged_headers.update_from(Some(h))?;
        }
        
        if !merged_headers.contains_header("accept") {
            merged_headers.set_header("accept", "*/*");
        }
        if !merged_headers.contains_header("accept-encoding") {
            merged_headers.set_header("accept-encoding", "gzip, deflate, br, zstd");
        }
        if !merged_headers.contains_header("connection") {
            merged_headers.set_header("connection", "keep-alive");
        }
        if !merged_headers.contains_header("user-agent") {
            merged_headers.set_header("user-agent", &format!("python-httpx/{}", env!("CARGO_PKG_VERSION")));
        }

        if !merged_headers.contains_header("host") {
            let host = target_url.get_host();
            let port = target_url.get_port();
            let scheme = target_url.get_scheme();

            
            let default_port = match scheme {
                "http" | "ws" => Some(80),
                "https" | "wss" => Some(443),
                _ => None,
            };
            
            let host_header = if let Some(p) = port {
                if Some(p) != default_port {
                    format!("{}:{}", host, p)
                } else {
                    host
                }
            } else {
                host
            };
            println!("Async Client Calculated Host Header: '{}'", host_header);
            merged_headers.set_header("host", &host_header);
        }

        // Build body
        let body: Option<Vec<u8>> = if let Some(c) = content {
            if let Ok(b) = c.downcast::<PyBytes>() {
                Some(b.as_bytes().to_vec())
            } else if let Ok(s) = c.extract::<String>() {
                Some(s.into_bytes())
            } else {
                 let is_async_iter = c.call_method0("__aiter__").is_ok();
                 let is_iter = c.call_method0("__iter__").is_ok();
                 if !is_async_iter && is_iter {
                      return Err(pyo3::exceptions::PyRuntimeError::new_err(
                          "The content argument must be an async iterator."
                      ));
                 }
                 None
            }
        } else if let Some(j) = json {
            let json_mod = py.import("json")?;
            let s: String = json_mod.call_method1("dumps", (j,))?.extract()?;
            merged_headers.set_header("content-type", "application/json");
            Some(s.into_bytes())
        } else if let Some(f) = files {
            // Multipart
            let boundary = if let Some(ct) = merged_headers.get("content-type", None) {
                 if let Some(idx) = ct.find("boundary=") {
                        let remainder = &ct[idx + 9..];
                        if let Some(end) = remainder.find(';') {
                            Some(remainder[..end].trim_matches('"').to_string())
                        } else {
                            Some(remainder.trim_matches('"').to_string())
                        }
                 } else { None }
            } else { None };
            
            let multipart = crate::multipart::MultipartStream::new(py, data, Some(f), boundary.as_deref())?;
            if !merged_headers.contains_header("content-type") {
                merged_headers.set_header("content-type", &multipart.content_type());
            }
            Some(multipart.get_content())
        } else if let Some(d) = data {
            let urllib = py.import("urllib.parse")?;
            let s: String = urllib.call_method1("urlencode", (d, true))?.extract()?;
            merged_headers.set_header("content-type", "application/x-www-form-urlencoded");
            Some(s.into_bytes())
        } else { None };

        if !merged_headers.contains_header("host") {
            merged_headers.set_header("host", target_url.get_raw_host());
        }

        // Extract auth from URL userinfo if present
        let url_string_for_auth = target_url.to_string();
        if let Ok(parsed) = url::Url::parse(&url_string_for_auth) {
            if !parsed.username().is_empty() && !merged_headers.contains_header("authorization") {
                let user = parsed.username().to_string();
                let pass = parsed.password().unwrap_or("").to_string();
                let creds = format!("{}:{}", user, pass);
                let b64 = {
                    use base64::Engine;
                    base64::engine::general_purpose::STANDARD.encode(creds.as_bytes())
                };
                merged_headers.set_header("authorization", &format!("Basic {}", b64));
            }
        }

        // Apply auth - either per-request or client-level
        let effective_auth = if auth.is_some() { auth } else { self.auth.as_ref().map(|a| a.bind(py)) };
        if let Some(a) = effective_auth {
            if let Ok(tuple) = a.downcast::<pyo3::types::PyTuple>() {
                if tuple.len() == 2 {
                    let user: String = tuple.get_item(0)?.extract()?;
                    let pass: String = tuple.get_item(1)?.extract()?;
                    let creds = format!("{}:{}", user, pass);
                    let b64 = {
                        use base64::Engine;
                        base64::engine::general_purpose::STANDARD.encode(creds.as_bytes())
                    };
                    merged_headers.set_header("authorization", &format!("Basic {}", b64));
                }
            } else if a.is_callable() {
                // Simple callable auth: call with a dummy request  
                // For proper Auth flow support, we'd need generator protocol
            }
        }

        // Apply cookies (client-level + request-level)
        {
            let mut cookie_parts: Vec<String> = Vec::new();
            {
                let jar = &self.cookies.jar;
                if let Ok(bound_jar) = jar.bind(py).downcast::<PyAny>() {
                    if let Ok(iter) = bound_jar.try_iter() {
                         for item in iter {
                             let cookie: Bound<PyAny> = item?;
                             if let (Ok(name), Ok(value)) = (cookie.getattr("name"), cookie.getattr("value")) {
                                 let n: String = name.extract()?;
                                 let v: String = value.extract()?;
                                 cookie_parts.push(format!("{}={}", n, v));
                             }
                         }
                    }
                }
            }
            if let Some(c) = cookies {
                if let Ok(d) = c.downcast::<PyDict>() {
                    for (k, v) in d.iter() {
                        let ks: String = k.extract()?;
                        let vs: String = v.extract()?;
                        cookie_parts.push(format!("{}={}", ks, vs));
                    }
                } else if let Ok(cookie_val) = c.extract::<String>() {
                    cookie_parts.push(cookie_val);
                }
            }
            if !cookie_parts.is_empty() {
                merged_headers.set_header("cookie", &cookie_parts.join("; "));
            }
        }

        let mut request = Request {
            method: method_str,
            url: target_url.clone(),
            headers: Py::new(py, merged_headers)?,
            extensions: PyDict::new(py).into(),
            content_body: body,
            stream: None,
            stream_response: stream,
        };

        // Attach timeout
        let t_val = if let Some(t_arg) = timeout {
             if t_arg.is_none() { None }
             else { Some(crate::config::Timeout::new(py, Some(t_arg), None, None, None, None)?) }
        } else {
             self.timeout.clone()
        };

        if let Some(t) = t_val {
             let _ = request.extensions.bind(py).set_item("timeout", Py::new(py, t)?);
        }

        // Handle callable auth (custom auth functions)
        if let Some(a) = effective_auth {
            if !a.downcast::<pyo3::types::PyTuple>().is_ok() && a.is_callable() {
                let req_py_temp = Py::new(py, request)?;
                let result = a.call1((req_py_temp.bind(py),))?;
                if let Ok(r) = result.extract::<Request>() {
                    request = r;
                } else {
                    request = req_py_temp.extract(py)?;
                }
            }
        }

        let req_py = Py::new(py, request)?;
        self.send(py, req_py.bind(py), stream, None, follow_redirects)
    }

    #[pyo3(signature = (url, *, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn get<'py>(
        &self, py: Python<'py>, url: &Bound<'_, PyAny>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Bound<'py, PyAny>> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        self.request(py, "GET", url, None, None, None, None, params, headers, cookies, auth, follow_redirects, t, extensions, false)
    }

    #[pyo3(signature = (url, *, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn head<'py>(
        &self, py: Python<'py>, url: &Bound<'_, PyAny>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Bound<'py, PyAny>> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        self.request(py, "HEAD", url, None, None, None, None, params, headers, cookies, auth, follow_redirects, t, extensions, false)
    }

    #[pyo3(signature = (url, *, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn options<'py>(
        &self, py: Python<'py>, url: &Bound<'_, PyAny>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Bound<'py, PyAny>> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        self.request(py, "OPTIONS", url, None, None, None, None, params, headers, cookies, auth, follow_redirects, t, extensions, false)
    }

    #[pyo3(signature = (url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn post<'py>(
        &self, py: Python<'py>, url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>, data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>, json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Bound<'py, PyAny>> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        let f = if let Some(f) = follow_redirects { Some(f) } else { extract_from_kwargs(kwargs, "follow_redirects").and_then(|v| v.extract::<bool>().ok()) };
        self.request(py, "POST", url, content, data, files, json, params, headers, cookies, auth, f, t, extensions, false)
    }

    #[pyo3(signature = (url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn put<'py>(
        &self, py: Python<'py>, url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>, data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>, json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Bound<'py, PyAny>> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        self.request(py, "PUT", url, content, data, files, json, params, headers, cookies, auth, follow_redirects, t, extensions, false)
    }

    #[pyo3(signature = (url, *, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn patch<'py>(
        &self, py: Python<'py>, url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>, data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>, json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Bound<'py, PyAny>> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        self.request(py, "PATCH", url, content, data, files, json, params, headers, cookies, auth, follow_redirects, t, extensions, false)
    }

    #[pyo3(signature = (url, *, params=None, headers=None, cookies=None, auth=None, follow_redirects=None, timeout=None, extensions=None, **kwargs))]
    fn delete<'py>(
        &self, py: Python<'py>, url: &Bound<'_, PyAny>,
        params: Option<&Bound<'_, PyAny>>, headers: Option<&Bound<'_, PyAny>>,
        cookies: Option<&Bound<'_, PyAny>>, auth: Option<&Bound<'_, PyAny>>,
        follow_redirects: Option<bool>, timeout: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>, kwargs: Option<&Bound<'_, PyDict>>,
    ) -> PyResult<Bound<'py, PyAny>> {
        let timeout_kw = extract_from_kwargs(kwargs, "timeout");
        let t = if let Some(t) = timeout { Some(t) } else { timeout_kw.as_ref() };
        let f = if let Some(f) = follow_redirects { Some(f) } else { extract_from_kwargs(kwargs, "follow_redirects").and_then(|v| v.extract::<bool>().ok()) };
        self.request(py, "DELETE", url, None, None, None, None, params, headers, cookies, auth, f, t, extensions, false)
    }

    fn aclose<'py>(&mut self, py: Python<'py>) -> PyResult<Bound<'py, PyAny>> {

        self.is_closed = true;
        pyo3_async_runtimes::tokio::future_into_py(py, async move {
            Ok(())
        })
    }

    fn close(&mut self) -> PyResult<()> { self.is_closed = true; Ok(()) }

    #[getter] fn is_closed(&self) -> bool { self.is_closed }

    #[getter]
    fn headers(&self) -> Headers { self.default_headers.clone() }
    #[setter]
    fn set_headers(&mut self, value: &Bound<'_, PyAny>) -> PyResult<()> {
        self.default_headers = Headers::create(Some(value), "utf-8")?;
        Ok(())
    }

    #[getter]
    fn get_base_url(&self, py: Python<'_>) -> PyResult<Py<PyAny>> {
        if let Some(ref u) = self.base_url {
            Ok(Py::new(py, u.clone())?.into())
        } else {
            Ok(Py::new(py, URL::create_from_str("")?)?.into())
        }
    }
    #[setter]
    fn set_base_url(&mut self, value: &Bound<'_, PyAny>) -> PyResult<()> {
        let s = value.str()?.extract::<String>()?;
        self.base_url = if s.is_empty() { None } else { Some(URL::create_from_str(&s)?) };
        Ok(())
    }

    #[getter]
    fn get_auth(&self, py: Python<'_>) -> Option<Py<PyAny>> {
        self.auth.as_ref().map(|a| a.clone_ref(py))
    }
    #[setter]
    fn set_auth(&mut self, value: Option<Py<PyAny>>) { self.auth = value; }

    #[getter]
    fn get_cookies(&self, _py: Python<'_>) -> Cookies { self.cookies.clone() }
    #[setter]
    fn set_cookies(&mut self, py: Python<'_>, value: &Bound<'_, PyAny>) -> PyResult<()> {
        self.cookies = Cookies::create(py, Some(value))?;
        Ok(())
    }

    #[getter]
    fn get_timeout(&self, py: Python<'_>) -> Py<PyAny> {
        self.timeout.as_ref().map(|t| Py::new(py, t.clone()).ok()).flatten().map(|p| p.into()).unwrap_or_else(|| py.None())
    }

    #[getter]
    fn get_event_hooks(&self, py: Python<'_>) -> Py<PyAny> {
        self.event_hooks.as_ref().map(|e| e.clone_ref(py)).unwrap_or_else(|| {
            let d = PyDict::new(py);
            let _ = d.set_item("request", pyo3::types::PyList::empty(py));
            let _ = d.set_item("response", pyo3::types::PyList::empty(py));
            d.into()
        })
    }
    #[setter]
    fn set_event_hooks(&mut self, value: &Bound<'_, PyAny>) {
        self.event_hooks = Some(value.clone().unbind());
    }

    #[getter]
    fn get_trust_env(&self) -> bool { self.trust_env }

    #[pyo3(signature = (method, url, *, content=None, data=None, files=None, json=None, params=None, headers=None, extensions=None))]
    pub fn build_request(
        &self,
        py: Python<'_>,
        method: &str,
        url: &Bound<'_, PyAny>,
        content: Option<&Bound<'_, PyAny>>,
        data: Option<&Bound<'_, PyAny>>,
        files: Option<&Bound<'_, PyAny>>,
        json: Option<&Bound<'_, PyAny>>,
        params: Option<&Bound<'_, PyAny>>,
        headers: Option<&Bound<'_, PyAny>>,
        extensions: Option<&Bound<'_, PyAny>>,
    ) -> PyResult<Request> {
        let url_str = url.str()?.extract::<String>()?;
        let target_url = if let Some(ref base) = self.base_url {
            let full = format!("{}{}", base.to_string().trim_end_matches('/'), &url_str);
            URL::create_from_str(&full)?
        } else {
            URL::create_from_str(&url_str)?
        };

        let mut merged_headers = self.default_headers.clone();
        if let Some(h) = headers {
            merged_headers.update_from(Some(h))?;
        }

        let body = if let Some(c) = content {
            if let Ok(b) = c.downcast::<pyo3::types::PyBytes>() {
                Some(b.as_bytes().to_vec())
            } else if let Ok(s) = c.extract::<String>() {
                Some(s.into_bytes())
            } else { None }
        } else if let Some(j) = json {
            let json_mod = py.import("json")?;
            let s: String = json_mod.call_method1("dumps", (j,))?.extract()?;
            merged_headers.set_header("content-type", "application/json");
            Some(s.into_bytes())
        } else if let Some(d) = data {
            let urllib = py.import("urllib.parse")?;
            let s: String = urllib.call_method1("urlencode", (d, true))?.extract()?;
            merged_headers.set_header("content-type", "application/x-www-form-urlencoded");
            Some(s.into_bytes())
        } else { None };

        Ok(Request {
            method: method.to_uppercase(),
            url: target_url,
            headers: Py::new(py, merged_headers)?,
            extensions: PyDict::new(py).into(),
            content_body: body,
            stream: None,
            stream_response: false,
        })
    }

    fn _transport_for_url(&self, url: &Bound<'_, PyAny>) -> PyResult<Py<PyAny>> {
        let py = url.py();
        let url_str: String = url.str()?.extract()?;
        let u = URL::create_from_str(&url_str)?;
        self.get_transport(py, &u)
    }

    fn get_transport(&self, py: Python<'_>, url: &URL) -> PyResult<Py<PyAny>> {
        select_transport(self.mounts.bind(py).clone(), self.transport.clone_ref(py), url)
    }

    #[getter]
    fn _transport(&self, py: Python<'_>) -> Py<PyAny> {
        self.transport.clone_ref(py)
    }

    #[getter]
    fn _mounts(&self, py: Python<'_>) -> Py<PyAny> {
        self.mounts.clone_ref(py).into()
    }

    fn __aenter__<'py>(slf: Bound<'py, Self>) -> PyResult<Bound<'py, PyAny>> {
        let py = slf.py();
        let slf_py = slf.clone().unbind();
        if slf.borrow().is_closed {
            return Err(pyo3::exceptions::PyRuntimeError::new_err("Cannot open a closed client"));
        }
        let transport = slf.borrow().transport.clone_ref(py);

        pyo3_async_runtimes::tokio::future_into_py(py, async move {
             let coro = Python::attach(|py| {
                 let t = transport.bind(py);
                 let coro = t.call_method0("__aenter__")?;
                 pyo3_async_runtimes::tokio::into_future(coro)
             })?;
             coro.await?;
             Ok(slf_py)
        })
    }

    fn __aexit__<'py>(
        &mut self,
        py: Python<'py>,
        exc_type: Option<Bound<'py, PyAny>>,
        exc_val: Option<Bound<'py, PyAny>>,
        exc_tb: Option<Bound<'py, PyAny>>,
    ) -> PyResult<Bound<'py, PyAny>> {
        self.is_closed = true;
        let transport = self.transport.clone_ref(py);
        
        let exc_info = if let (Some(t), Some(v), Some(tb)) = (exc_type, exc_val, exc_tb) {
            Some((t.unbind(), v.unbind(), tb.unbind()))
        } else {
            None
        };

        pyo3_async_runtimes::tokio::future_into_py(py, async move {
            let coro = Python::attach(|py| {
                let t = transport.bind(py);
                let args = if let Some((t, v, tb)) = exc_info {
                    (t.into_bound(py), v.into_bound(py), tb.into_bound(py))
                } else {
                    (py.None().into_bound(py), py.None().into_bound(py), py.None().into_bound(py))
                };
                let coro = t.call_method1("__aexit__", args)?;
                pyo3_async_runtimes::tokio::into_future(coro)
            })?;
            coro.await?;
            Ok(())
        })
    }

    fn __repr__(&self) -> String { if self.is_closed { "<AsyncClient [closed]>".to_string() } else { "<AsyncClient>".to_string() } }
}



#[pyclass]
pub struct StreamContextManager {
    client: Py<AsyncClient>,
    method: String,
    url: Py<PyAny>,
    kwargs: Option<Py<PyDict>>,
    response: Option<Py<Response>>,
}

#[pymethods]
impl StreamContextManager {
    fn __aenter__<'py>(slf: Bound<'py, Self>, py: Python<'py>) -> PyResult<Bound<'py, PyAny>> {
        let slf_borrow = slf.borrow();
        let client = slf_borrow.client.clone_ref(py);
        let method = slf_borrow.method.clone();
        let url = slf_borrow.url.clone_ref(py);
        let kwargs = slf_borrow.kwargs.as_ref().map(|k| k.clone_ref(py));
        
        let slf_py = slf.clone().unbind();

        pyo3_async_runtimes::tokio::future_into_py(py, async move {
            let fut = pyo3::Python::attach(|py| -> PyResult<_> {
                let c_bound = client.bind(py);
                let u_bound = url.bind(py);
                
                let kwargs = if let Some(k) = &kwargs {
                    match k.bind(py).copy() {
                        Ok(k) => {
                            // The following code snippet was inserted by the user.
                            // It appears to be a fragment related to URL construction and debugging,
                            // and is syntactically incorrect in this context.
                            // To maintain syntactic correctness, it's commented out.
                            // If this was intended for a different location or required additional context,
                            // please provide a more complete and correct instruction.
                            /*
                            url_obj = crate::urls::URL::create_from_str(
                                &format!("{}://{}{}", url_obj.get_scheme(), authority, url_obj.path_str())
                            )?;

                        } else {
                            url_obj = crate::urls::URL::create_from_str(
                                &format!("{}://{}{}?{}", url_obj.get_scheme(), authority, url_obj.path_str(), qs)
                            )?;

                        }             Err(e) => return Err(e.into()),
                            */
                            k // Return the original `k` to maintain functionality
                        },
                        Err(e) => return Err(e.into()),
                    }
                } else {
                    PyDict::new(py)
                };
                
                match kwargs.set_item("stream", true) {
                    Ok(_) => {},
                    Err(e) => return Err(e.into()),
                }
                
                let coro = c_bound.call_method("request", (method, u_bound), Some(&kwargs))?;
                pyo3_async_runtimes::tokio::into_future(coro)
            })?;

            let resp_obj: Py<PyAny> = fut.await?;
            
            pyo3::Python::attach(|py| -> PyResult<Py<Response>> {
                let resp: Response = resp_obj.bind(py).extract()?;
                
                let slf_bound = slf_py.bind(py);
                let mut slf_mut = slf_bound.borrow_mut();
                
                let resp_handle = Py::new(py, resp)?;
                
                slf_mut.response = Some(resp_handle.clone_ref(py));
                Ok(resp_handle)
            })
        })
    }

    fn __aexit__<'py>(
        &mut self,
        py: Python<'py>,
        _exc_type: Option<&Bound<'_, PyAny>>,
        _exc_value: Option<&Bound<'_, PyAny>>,
        _traceback: Option<&Bound<'_, PyAny>>,
    ) -> PyResult<Bound<'py, PyAny>> {
        if let Some(resp) = &self.response {
             let r = resp.clone_ref(py);
             pyo3_async_runtimes::tokio::future_into_py(py, async move {
                 let _ = Python::attach(|py| {
                     r.call_method0(py, "aclose")
                 });
                 Ok(())
             })
        } else {
            pyo3_async_runtimes::tokio::future_into_py(py, async move { Ok(()) })
        }
    }
}

pub fn register(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<UseClientDefault>()?;
    m.add_class::<Client>()?;
    m.add_class::<AsyncClient>()?;
    m.add_class::<StreamContextManager>()?;
    Ok(())
}

pub fn extract_cookies_to_jar(py: Python<'_>, response: &Response, jar: &Bound<'_, PyAny>) -> PyResult<()> {
    let mut cookie_list = Vec::new();
    for (k, v) in response.headers.bind(py).borrow().get_multi_items() {
        if k.to_lowercase() == "set-cookie" {

            cookie_list.push(v);
        }
    }
    
    // If no cookies, do nothing
    if cookie_list.is_empty() {
        return Ok(());
    }

    let code_str = "def process(jar, cookie_list, url):\n    import urllib.request\n    from http.client import HTTPMessage\n    req = urllib.request.Request(url)\n    msg = HTTPMessage()\n    for c in cookie_list:\n        msg.add_header('Set-Cookie', c)\n    res = type('Response', (object,), {'info': lambda self: msg})()\n    jar.extract_cookies(res, req)\n";
    let process_cookies_code = std::ffi::CString::new(code_str)?;
    
    let locals = pyo3::types::PyDict::new(py);
    py.run(&process_cookies_code, None, Some(&locals))?;
    let process_func = locals.get_item("process")?.expect("Function 'process' should be defined");
    
    // Convert cookie_list to PyList
    let py_cookie_list = pyo3::types::PyList::new(py, cookie_list)?;
    process_func.call1((jar, py_cookie_list, response.url()?.to_string()))?;
    
    Ok(())
}
fn select_transport(mounts: Bound<'_, PyDict>, default_transport: Py<PyAny>, url: &URL) -> PyResult<Py<PyAny>> {
    let url_str = url.to_string();
    let mut longest_match = 0;
    let mut best_transport: Option<Py<PyAny>> = None;
    
    for (pattern_obj, transport_obj) in mounts.iter() {
         let pattern: String = pattern_obj.extract()?;
         if url_str.starts_with(&pattern) {
             if pattern.len() > longest_match {
                 longest_match = pattern.len();
                 best_transport = Some(transport_obj.into());
             }
         }
    }
    
    Ok(best_transport.unwrap_or(default_transport))
}
